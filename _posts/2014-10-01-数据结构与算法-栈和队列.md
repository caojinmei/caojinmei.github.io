---
layout: post
title: "数据结构与算法-栈和队列"
date: 2014-08-01
categories:: 数据结构与算法
tags:
    - 数据结构
    - 算法
    - 编程
    - 栈和队列
---

# 定义
栈: 一种先进后出（LIFO）的数据结构   
队列: 一种先进先出（FIFO）的数据结构  
栈和队列是两种重要的线性结构。  
从数据结构的角度来看，栈和队列也是线性表。  
其特殊性在于栈和队列的基本操作是线性表操作的子集。  

既然这两种数据结构是线性表的子集，那为什么需要栈和队列这两种数据结构呢？这和操作系统的一些处理机制有关。  
在操作系统中，有一些函数调用，需要保存上下文。逐级调用，逐级退出，和栈的性质很类似。所以，栈可以很方便地保存和操作数据。  
操作系统还要接收用户地操作，并作出及时的反馈。这种结构称为消息队列。按照先进先出的顺序，按部就班的完成用户请求的操作。  
如果没有栈和队列，这些数据的保存和处理流程会很复杂。  

除了栈和队列之外，还有一种限定性数据结构是双端队列。顾名思义，它可以在两端进行插入和删除操作。 
尽管它看起来似乎比栈和队列更灵活，但实际上很少用。  

# 表示方法
```
ADT Stack {
    数据对象: D = { a1, a2, ... }
    数据关系: R1 = { <ai-1, ai> }
    基本操作:
        InitStack(&S)
        DestroyStack(&S)
        ClearStack(&S)
        StackEmpty(S)
        StackLength(S)
        GetTop(S, &e)
        Push(&S, e)
        Pop(&S, &e)
        StackTraverse(S, visit())
}ADT Stack

ADT Queue {
    数据对象: D = { a1, a2, ... }
    数据关系: R1 = { <ai-1, ai> }
    基本操作:
        InitQueue(&S)
        DestroyQueue(&S)
        ClearQueue(&S)
        QueueEmpty(S)
        QueueLength(S)
        GetHead(S, &e)
        EnQueue(&S, e)
        DeQueue(&S, &e)
        QueueTraverse(S, visit())
}ADT Queue

```

# 练习题
#### 描述
如何用栈实现一个队列？ 

#### 分析
由于栈的性质是LIFO，则把栈两次取反则可以实现FIFO。故可以用两个栈互相“倾倒”来实现。

#### 代码
```
class Queue {
private:
    Stack<int> inStack;
    Stack<int> outStack;
public: 
    void enqueue(int);
    int dequeue();
};

void Queue:enqueue(int value) {
    inStack.push_back(value);
}

int dequeue() {
    if (!outStack.empty()) {
        int value = outStack.top();
        outStack.pop();
        return value;
    } 
    while (inStack.empty()) {
        outStack.push(inStack.top());
        inStack.pop();
    }
    int value = outStack.top();
    outStack.pop();
    return value;
}
```