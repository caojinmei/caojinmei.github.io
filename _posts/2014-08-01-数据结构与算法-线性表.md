---
layout: post
title: "数据结构与算法-线性表"
date: 2014-08-01
categories:: 数据结构与算法
tags:
    - 数据结构
    - 算法
    - 编程
    - 线性表
---

# 定义
n个数据元素的有限序列。

# 表示方法
### 顺序表示
数组
### 链式表示
链表

# 练习题
## 数组
### Remove Duplicates from Sorted array
#### 描述  
Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.  
Do not allocate extra space for another array, you must do this in place with constant memory.  
For example, Given input array A = [1,1,2],  
Your function should return length = 2, and A is now [1,2].    
#### 分析    
可以申请一个新的数组，遍历旧数组，逐个判断新数组最后一个元素和旧数组当前元素是否相等。  
该方案的时间复杂度和空间复杂度均为O(n).
优化方案   
直接遍历并修改该数组，最后返回数组的长度即可，新数组多于该长度的内容不需要关心。  
#### 代码  
```
class solution {
  int removeDuplicates(vector<int>& nums) {
    if (nums.empty()) return 0;
    int index = 0;
    for (int i = 1; i < nums.size(); i++) {
      if (nums[index] != nums[i]) {
        index++;
        nums[index] = nums[i];
      }
    }
    return index + 1;
  }
}
```

如果每个元素允许出现两次，该怎么做呢？
#### 描述
Follow up for ”Remove Duplicates”: What if duplicates are allowed at most twice? 
For example, Given sorted array A = [1,1,1,2,2,3], 
Your function should return length = 5, and A is now [1,1,2,2,3] 

#### 分析
需要一个变量来表示重复的次数。 
如果数组是无须的，则需要hashmap来记录次数。 
#### 代码
```
class solution {
public:
  int removeDuplicates(vector<int> &nums) {
    if (nums.size() <= 2) return nums.size()
    int index = 0;
    for (int i = 2; i < nums.size(); i++) {
      if (nums[i] != nums[index]) {
        nums[index + 2] = nums[i];
        index++;
      }
    }
    return index + 2;
  }
}
```

## 单链表
### Remove Duplicates from Sorted List
#### 描述
Given a sorted linked list, delete all duplicates such that each element appear only once.   
For example, Given 1->1->2, return 1->2.  
Given 1->1->2->3->3, return 1->2->3.  

#### 分析
逐个比较链表节点，删除重复节点

#### 代码
```
// 迭代版
class solution {
public:
  ListNode *deleteDuplicates(ListNode *head) {
    if (head == nullptr) return nullptr;
    ListNode *prev = head;
    ListNode *cur = head->next;
    while (cur) {
      if (prev->val == cur->val) {
        prev->next = cur->next;
        delete cur;
      } else {
        prev = cur;
      }
      cur = cur->next;
    }
    return head;
  }
}
```
